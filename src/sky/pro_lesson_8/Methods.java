package sky.pro_lesson_8;

import java.time.LocalDate;
import java.util.Arrays;
import java.util.Random;

public class Methods {
    public static void main(String[] args) {
        //task1(2020);
        //task2(1, 2021);
        //task3(1000);
        //task4("Ivanovich");
        //task5(new int[]{3, 2, 1, 6, 5});
        task6(generateRandomArray());
    }

    public static void task1(int leapYear) {
        /*
       Задание 1
       Реализуйте метод, который получает в качестве параметра год, а затем проверяет, является ли он високосным,
       и выводит результат в консоль.  Эту проверку вы уже реализовывали в задании по условным операторам.
       Теперь проверку нужно обернуть в метод и использовать год, который приходит в виде параметра.
       Результат программы выведите в консоль. Если год високосный, то должно быть выведено “*номер года —* високосный год”.
       Если год не високосный, то, соответственно: “*номер года —* не **високосный год”.
         */
        if ((leapYear % 4 == 0) && (leapYear % 100 > 0) || (leapYear % 400 == 0)) {
            System.out.println(leapYear + " год является високосным.");
        } else {
            System.out.println(leapYear + " год не является високосным.");
        }
    }

    public static void task2(int enterClientOs, int clientDeviceYear) {
        /*
        Задание 2
        Вспомним задание 2 по условным операторам, где нам необходимо было предложить пользователю облегченную версию приложения.
        - Текст прошлого задания
        К нам пришли коллеги и сообщили, что нам нужно знать не только операционную систему телефона,
        но и год его создания: от этого зависит, подойдет ли приложение для телефона или оно просто не установится.
        Если телефон произведен с 2015 по нынешний год, то приложение будет работать корректно.
        Если телефон произведен ранее 2015 года, то клиенту нужно посоветовать установить облегченную версию приложения.
        Ваша задача: написать программу, которая выдает соответствующее сообщение клиенту при наличии двух условий —
        операционной системы телефона (iOS или Android) и года производства.
        Если год выпуска ранее 2015 года, то к сообщению об установке нужно добавить информацию об облегченной версии.
        Например, для iOS оно будет звучать так:
        «Установите облегченную версию приложения для iOS по ссылке».
        А для Android так:
        «Установите облегченную версию приложения для Android по ссылке».
        При этом для пользователей с телефоном с 2015 года выпуска нужно вывести обычное предложение об установке приложения.
        Для обозначения года создания используйте переменную clientDeviceYear, где необходимо указать 2015 год.
        **Важно**: вложенность больше двух этажей не допускается (условный оператор внутри условного оператора).
        Напишите метод, куда подаются два параметра: тип операционной системы (ОС) ( 0 — iOS или 1 — Android ) и год выпуска устройства.
        Если устройство старше текущего года, предложите ему установить lite-версию (облегченную версию).
        Текущий год можно получить таким способом:
        ```java
        int currentYear = LocalDate.now().getYear();
        Или самим задать значение вручную, введя в переменную числовое значение.
        В результате программа должна выводить в консоль в зависимости от исходных данных,
        какую версию приложения (обычную или lite) и для какой ОС (Android или iOS) нужно установить пользователю.
        *Подсказку с выполнением задания вы можете найти в шпаргалке урока.*
         */
        int currentYear = LocalDate.now().getYear();

        boolean isLiteNeeded = clientDeviceYear < currentYear;
        boolean isIos = enterClientOs == 0;
        boolean isAndroid = enterClientOs == 1;
        if (isIos) {
            if (isLiteNeeded) {
                System.out.println("Установите облегченную версию приложения для iOS по ссылке");
            } else {
                System.out.println("Установите версию приложения для iOS по ссылке.");
            }
        } else if (isAndroid) {
            if (isLiteNeeded) {
                System.out.println("Установите облегченную версию приложения для Android по ссылке");
            } else {
                System.out.println("Установите версию приложения для Android по ссылке");
            }
        } else {
            System.out.println("Такого приложения нет. Обратитесь к продавцу.");
        }
    }


    public static void task3(int deliveryDistance) {
        /*
        Задание 3
        Возвращаемся к любимой многими задаче на расчет дней доставки банковской карты от банка.
        Наша задача — доработать код, а именно написать метод, который на вход принимает дистанцию
        и возвращает итоговое количество дней доставки.
         */
        int countDay = 1;
        if (deliveryDistance <= 20) {
            System.out.println("Потребуется дней: " + countDay);
        } else if (deliveryDistance <= 60) {
            countDay++;
            System.out.println("Потребуется дней: " + countDay);
        } else if (deliveryDistance <= 100) {
            countDay += 2;
            System.out.println("Потребуется дней: " + countDay);
        } else {
            System.out.println("Доставки в указаных пределах: " + deliveryDistance + " км. Нет.");
        }
    }

    public static void task4(String text) {
        /*
        Задание 4
        Вернемся к задаче о валидаторе текста из урока по строкам.
        Напишите метод, который в виде параметра принимает отсортированную строку.
        Например, aabccddefgghiijjkk.
        С помощью цикла проверьте, что в строке нет дублей, и выведите в консоль сообщение об этом.
        Если дубль найден, нужно прервать поиск по остальным символам и вывести сообщение о присутствии дубля,
        причем с указанием, какой именно символ задублирован. Затем сразу же прервать выполнение метода.
        Сам метод ничего возвращать не должен (void).
         */
        //sortString(text);
        check(text);

    }

    public static String sortString(String str) {
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        return new String(chars);
    }

    public static void check(String s) {
        int count = 0;
        String string = s.toLowerCase();
        string = sortString(string);
        char[] chars = string.toCharArray();
        System.out.println(chars);
        for (int i = 0; i < chars.length; i++) {
            count = 1;
            for (int j = i + 1; j < chars.length; j++) {
                if (chars[i] == chars[j]) {
                    count++;
                }
            }
            if (count > 1) {
                System.out.println("Символ " + chars[i] + " задублирован.");
                break;
            }
        }
    }

    public static void task5(int[] numbers) {
        /*
        Задание 5
        Напишите метод, который получает на вход массив и переставляет все его элементы в обратном порядке.
        Подобное задание вы решали в домашнем задании по массивам.
        **Важно**: не используйте дополнительные массивы для решения этой задачи.
        Необходимо корректно пройти по массиву циклом и распечатать его элементы в правильном порядке.
        В метод приходит массив, допустим:{3, 2, 1, 6, 5}.
        Нужно без вспомогательного массива переместить элементы так, чтобы поданный массив стал: {5, 6, 1, 2, 3}.
        Рекомендуем написать этот метод без возвращаемого значения. Вы будете приятно удивлены,
        что даже если мы не вернем массив, первоначальный массив изменится,
        когда мы будем модернизировать пришедший в виде параметра массив внутри метода.
        Причину такого поведения ссылочных типов (объектов) вы узнаете на следующем уроке или на QA-вебинаре.
         */
        for (int i = 0; i < numbers.length; i++) {
            System.out.print(numbers[i] + " ");
        }
        System.out.println();
        for (int i = numbers.length - 1; i >= 0; i--) {
            System.out.print(numbers[i] + " ");
        }
    }

    public static void task6(int[] arr) {
        /*
        Повышенный уровень. Задание 6
        Снова вспоминаем домашнее задание по массивам. В нем была задача, которая требовала высчитать среднюю выплату за день.
        Был дан сгенерированный массив из 30 значений от 100 до 200 тысяч, для его генерации допускается использовать
        метод из прошлого домашнего задания.
        - Текст прошлого задания
        Нам нужно понять, какую в среднем сумму наша компания тратила в течение данных 30 дней.
        Нужно написать программу, которая посчитает среднее значение трат за месяц
        (то есть сумму всех трат за месяц поделить на количество дней), и вывести в консоль результат в формате:
        «Средняя сумма трат за месяц составила … рублей».
        **Важно помнить:** подсчет среднего значения может иметь остаток (то есть быть не целым, а дробным числом).
        Нужно сгенерировать массив, подать его в наш метод, а  внутри метода  подсчитать сумму элементов и
        вычислить среднее значение,  которое нужно вернуть из метода в виде результата.
        Сложность в том, что метод нужно не просто написать, но еще и декомпозировать.
        То есть для работы этого метода нужно будет создать еще методы (1 или более),
        которые его будут обслуживать и вычислять промежуточные результаты.
        Среднее значение нужно вычислять в дробном виде, так как результат должен быть точным.
         */
        show(generateRandomArray());
    }

    public static void findMean(int[] arr) {
        arr = generateRandomArray();
        double average = 0;
        double totalSum = 0;
        for (int i : arr) {
            totalSum += i;
            average = totalSum / arr.length;
        }
        System.out.println("Средняя сумма трат за месяц составила " + average + " рублей");
    }

    public static void show(int[] arr) {
        arr = generateRandomArray();
        for (int i = 0; i < arr.length; i++) {
            System.out.println("Затраты за " + (i + 1) + " день " + arr[i]);
        }
        findMean(generateRandomArray());
    }

    private static int[] generateRandomArray() {
        Random random = new Random();
        int[] arr = new int[30];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(100000) + 100000;
        }
        return arr;
    }
}
